{
  "engines": {
    "node": ">=0.4.7"
  },
  "repository": {
    "url": "git://github.com/frodwith/node-init.git",
    "type": "git"
  },
  "maintainers": [
    {
      "name": "Paul Driver",
      "email": "frodwith@gmail.com"
    }
  ],
  "version": "0.1.2",
  "licences": [
    {
      "url": "http://www.opensource.org/licenses/mit-license",
      "type": "MIT License"
    }
  ],
  "dependencies": {
    "daemon": ">=0.3.0"
  },
  "name": "init",
  "bugs": {
    "url": "https://github.com/frodwith/node-init/issues"
  },
  "author": {
    "name": "Paul Driver",
    "email": "frodwith@gmail.com"
  },
  "description": "Turn your node daemon into an LSB-like init script",
  "main": "./init.js",
  "keywords": [
    "daemon",
    "init",
    "service",
    "LSB"
  ],
  "devDependencies": {},
  "contributors": [
    {
      "name": "Paul Driver",
      "email": "frodwith@gmail.com"
    }
  ],
  "readme": "Init\n====\n\nTurn your node daemon into an LSB-compatible init script.\n\nFor the impatient\n-----------------\n\n    init = require('init');\n\n    init.simple({\n        pidfile : '/var/run/myprog.pid',\n        logfile : '/var/log/myprog.log',\n        command : process.argv[3],\n        run     : function () {\n            doWhateverMyDaemonDoes();\n        }\n    })\n\ninit.simple() doesn't do what I want\n------------------------------------\nYou're in luck (maybe). simple() just makes the easy case easy. See the api\nmethods below for more flexible ways to use this module.\n\nAPI\n---\n\n### init.start(options)\n\nStarts your service. This function will not return, and takes the following\nkeyword arguments:\n\n#### pidfile\n\nRequired. This should be a path to a file to lock and store the daemon pid in.\nIf the daemon is already running according to this pidfile, start succeeds\nwithout doing anything.\n\n#### logfile\n\nPath to a file to redirect your daemon's stdout and stderr to. Defaults to\n/dev/null.\n\n#### run\n\nRequired. A function to be called after daemon setup is complete. Do your\ndaemon work here.\n\n#### success (pid, wasRunning)\n\nA function to be called when the start action succeeded (already running or\nabout to daemonize). 'pid' will be the id of the running process, and\n'wasRunning' is true if the process was already running.\n\n#### failure(error)\n\nA function to be called if the start action cannot be performed. Error will be\nsome sort of stringifiable error object. Defaults to init.startFailed.\n\n### init.stop(pidfile, cb, killer)\n\nStops your service with one of shutdown functions. Default is\n`init.hardKiller(2000)`, but you may pass your own.\n\n### init.status(pidfile, cb)\n\nGets the status of your service. The status is not returned, but rather will\nbe passed to cb if you provide it (defaults to init.printStatus). It is an\nobject of the form: { running: true, pid: 3472, exists: true }.\n\n### init.simple(options)\n\nHigher level method that leaves all the callbacks as defaults and dispatches\nto calling the right function depending on the string you provide. Takes the\nfollowing keyword arguments:\n\n#### pidfile\n#### run\n#### logfile\nAs in init.start()\n\n### killer\nAs in init.stop()\n\n#### command\nA string on which to dispatch. Defaults to your program's first argument\n(process.argv[2]). Recognized actions are \"start\", \"stop\", \"restart\",\n\"try-restart\", \"force-reload\", and \"status\".\n\n#### killer\nAs in init.stop()\n\nShutdown functions\n-----------------\n\n### init.hardKiller(delay = 2000)\n\nSends your service TERM, INT, QUIT, in that order (with 2000 ms delays) and\nthen KILL until the process is no longer running, then calls cb (defaults to\ninit.stopped). If the process was running, cb's first argument will be true.\nThis is the default shutdown function.\n\n### init.softKiller(delay = 2000)\n\nSends your service TERM and waits until it dies with 2000 ms delays. If it is\nmore important that your service shutdown gracefully (to preserve data\nintegrity, etc) than that it exits promptly, this is a good choice.\n\n\nDefault Actions\n---------------\nThese functions are the defaults for various callbacks, but you can call them\nfrom your own custom callbacks if you want to augment them instead of\nreplacing them.\n\n### init.startSucceeded(pid, wasRunning)\n\nPrints \"Started with PID n\" or \"Already running with PID n\" and exits with a 0\nstatus code.\n\n### init.startFailed(error)\n\nPrints error and exits with a 1 status code.\n\n### init.stopped(killed)\n\nPrints \"Stopped\" or \"Not running\" and exits with a 0 status code.\n\n### init.printStatus (status)\n\nPrints a human-readable message and exits with an LSB-appropriate error code.\n\nProgram is running:\n\n    Process is already running with pid N.\n    exit 0\n\nProgram is dead (exited without removing pid file)\n\n    Pidfile exists, but process is dead.\n    exit 2\n\nProgram is not running:\n\n    Not running.\n    exit 3\n",
  "readmeFilename": "README.markdown",
  "_id": "init@0.1.2",
  "dist": {
    "shasum": "559098eb22ce02f9086f9f381fe82d74db0c14f0"
  },
  "_from": "init@",
  "_resolved": "https://registry.npmjs.org/init/-/init-0.1.2.tgz"
}
